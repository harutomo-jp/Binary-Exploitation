# Introduction - 86x and x64 Assembly

Table of contents
- [Basic Instructions](#basic-instructions)
- [Basic Assembly Reversing Problems](#basic-assembly-reversing-problems)


# Basic Instructions

**mov** - The move instruciton just moves data from one register to another.  For instance:

```mov rax, rdx```

This will just move the data from the ```rdx``` register to the ```rax``` register.

---

**dereference**

If you ever see brackets like ```[]```, they are meant to dereference, which deals with pointsers.  A pointer is a value that points to a particular memory address (it is a memory address).  Dereferencing a pointer means to treat a pointer like hte value it points to.  For instance:

```mov rax, [rdx]```

Will move the value pointed to by ```rdx``` into the ```rax``` register.  On the flipside:

```mov [rax], rdx```

Will move the value of the ```rdx``` register into whatever memory is pointed to by the ```rax``` register.  The actual value of the ```rax``` register does not change. 

---

**lea**

The lea instruction calculates the address of the second operand, and moves that address in the first.  For instance:

```lea rdi, [rbx+0x10]```

This will move the address ```rbx+0x10``` into the ```rdi``` register.

---

**add**

This just adds the two values together, and stores the sum in the first argument.  For instance:

```add rax, rdx```

---

**xor**

This will perform the binary operation xor on the two arguments it is given, and stores the result in the first operation:

```xor rdx rax```

That will set the ```rdx``` register equal to ```rdx ^ rax```.

The ```and``` and ```or``` operations essentially do the same thing, except with the and or or binary operators.

---

**push**

The ```push``` instruction will grow the stack by either ```8``` bytes (for x64, 4 for x86), then push the contents of a register onto the new stack space.  For instance:

```push rax```

This will grow the stack by 8 bytes, and the contents of the ```rax``` register will be on top of the stack.

---

**pop**

The ```pop``` instruction will pop the top `8` bytes (for `x64`, `4` for `x86`) off the stack and into the argument.  Then it will shrink the stack.  For instance:

```pop rax```

The top `8` bytes of the stack will end up in the `rax` register.

---

**jmp**

The `jmp` instruction will jump to an instruction address.  It is used to redirect code execution.  For instance:

```jmp 0x602010```

That instruction will cause the code execution to jump to `0x602010`, and execute whatever instruction is there.

---

**call & ret**

This is similar to the `jmp` instruction.  The difference is it will push the values of `rbp` and `rip` onto the stack, then jump to whatever address it is given.  This is used for calling functions.  After the function is finished, a `ret` instruction is called which uses the pushed values of the `rbp` and `rip` (saved base and instruction pointers) it can continue execution right where it left off.

---

**cmp**

The cmp instruction is similar to that of the sub instruction.  Except it doesn't store the result in the first argument.  It checks if the result is less than zero, greater than zero, or equal to zero.  Depending on the value it will set the flags accordingly.

---

**jnz / jz**

This `jump if not zero` and `jump if zero` instructions are pretty similar to the jump instruction.  The difference is that they will only execute the jump depending on the status of the `zero` flag.  For `jz` it will only jump if the `zero` flag is set.  The opposite is true for `jnz`.

---

# Basic Assembly Reversing Problems

The purpose of these problems is to get some experience reversing assembly code.  Try to figure out what the binaries are doing.  To biew disassembly machine code into assembly code, you can use a commands like `objdump`.
https://github.com/kablaa/CTF-Workshop/blob/master/Reversing/Challenges/IfThen/if_then

**Problem 1: Hello World**

First, let's take a look at the assembly code:

`$	objdump -D hello_world -M intel | less`

After searching through for the string `main` to find the main function, we see the following:

```
080483fb <main>:
 80483fb:       8d 4c 24 04             lea    ecx,[esp+0x4]
 80483ff:       83 e4 f0                and    esp,0xfffffff0
 8048402:       ff 71 fc                push   DWORD PTR [ecx-0x4]
 8048405:       55                      push   ebp
 8048406:       89 e5                   mov    ebp,esp
 8048408:       51                      push   ecx
 8048409:       83 ec 04                sub    esp,0x4
 804840c:       83 ec 0c                sub    esp,0xc
 804840f:       68 b0 84 04 08          push   0x80484b0
 8048414:       e8 b7 fe ff ff          call   80482d0 <puts@plt>
 8048419:       83 c4 10                add    esp,0x10
 804841c:       b8 00 00 00 00          mov    eax,0x0
 8048421:       8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4]
 8048424:       c9                      leave
 8048425:       8d 61 fc                lea    esp,[ecx-0x4]
 8048428:       c3                      ret
 8048429:       66 90                   xchg   ax,ax
 804842b:       66 90                   xchg   ax,ax
 804842d:       66 90                   xchg   ax,ax
 804842f:       90                      nop
```

Looking at the code, we see a function call to `puts`:

```
 804840f:       68 b0 84 04 08          push   0x80484b0
 8048414:       e8 b7 fe ff ff          call   80482d0 <puts@plt>
```

Looking through the rest of the code, we really don't see much else that is interesting for our perspective.  So this code probably just prints a string.  When we run the binary, we see that is correct.

---

**Problem 2: If then**

We start off by viewing the assembly code with `objdump`:

```
$	objdump -D if_then -M intel | less
```

After parsing through for the `main` function, we see this:

```
080483fb <main>:
 80483fb:       8d 4c 24 04             lea    ecx,[esp+0x4]
 80483ff:       83 e4 f0                and    esp,0xfffffff0
 8048402:       ff 71 fc                push   DWORD PTR [ecx-0x4]
 8048405:       55                      push   ebp
 8048406:       89 e5                   mov    ebp,esp
 8048408:       51                      push   ecx
 8048409:       83 ec 14                sub    esp,0x14
 804840c:       c7 45 f4 0a 00 00 00    mov    DWORD PTR [ebp-0xc],0xa
 8048413:       83 7d f4 0a             cmp    DWORD PTR [ebp-0xc],0xa
 8048417:       75 10                   jne    8048429 <main+0x2e>
 8048419:       83 ec 0c                sub    esp,0xc
 804841c:       68 c0 84 04 08          push   0x80484c0
 8048421:       e8 aa fe ff ff          call   80482d0 <puts@plt>
 8048426:       83 c4 10                add    esp,0x10
 8048429:       b8 00 00 00 00          mov    eax,0x0
 804842e:       8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4]
 8048431:       c9                      leave
 8048432:       8d 61 fc                lea    esp,[ecx-0x4]
 8048435:       c3                      ret
 8048436:       66 90                   xchg   ax,ax
 8048438:       66 90                   xchg   ax,ax
 804843a:       66 90                   xchg   ax,ax
 804843c:       66 90                   xchg   ax,ax
 804843e:       66 90                   xchg   ax,ax
```

We can see that it loads the value `0xa` into `ebp-0xc`:

```
 mov    DWORD PTR [ebp-0xc],0xa
```

Immediately proceeding that, we see that it runs a `cmp` instruction on it to check if it is equal.  If they are not equal it will jump to `main+0x2e`.  Since it was just loaded with the value `0xa`, it should not make the jump:

```
 cmp    DWORD PTR [ebp-0xc],0xa
 jne    8048429 <main+0x2e>
```

proceeding that it should make a call to puts:

```
 sub    esp,0xc
 push   0x80484c0
 80482d0 <puts@plt>
```

So after looking at this code, we see that it should make that `puts` call.  When we run it, we see that is what it does.

