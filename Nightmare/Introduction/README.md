# Introduction - 86x and x64 Assembly

Table of contents
- [Basic Instructions](#basic-instructions)
- [Basic Assembly Reversing Problems](#basic-assembly-reversing-problems)


# Basic Instructions

**mov** - The move instruciton just moves data from one register to another.  For instance:

```mov rax, rdx```

This will just move the data from the ```rdx``` register to the ```rax``` register.

---

**dereference**

If you ever see brackets like ```[]```, they are meant to dereference, which deals with pointsers.  A pointer is a value that points to a particular memory address (it is a memory address).  Dereferencing a pointer means to treat a pointer like hte value it points to.  For instance:

```mov rax, [rdx]```

Will move the value pointed to by ```rdx``` into the ```rax``` register.  On the flipside:

```mov [rax], rdx```

Will move the value of the ```rdx``` register into whatever memory is pointed to by the ```rax``` register.  The actual value of the ```rax``` register does not change. 

---

**lea**

The lea instruction calculates the address of the second operand, and moves that address in the first.  For instance:

```lea rdi, [rbx+0x10]```

This will move the address ```rbx+0x10``` into the ```rdi``` register.

---

**add**

This just adds the two values together, and stores the sum in the first argument.  For instance:

```add rax, rdx```

---

**xor**

This will perform the binary operation xor on the two arguments it is given, and stores the result in the first operation:

```xor rdx rax```

That will set the ```rdx``` register equal to ```rdx ^ rax```.

The ```and``` and ```or``` operations essentially do the same thing, except with the and or or binary operators.

---

**push**

The ```push``` instruction will grow the stack by either ```8``` bytes (for x64, 4 for x86), then push the contents of a register onto the new stack space.  For instance:

```push rax```

This will grow the stack by 8 bytes, and the contents of the ```rax``` register will be on top of the stack.

---

**pop**

The ```pop``` instruction will pop the top `8` bytes (for `x64`, `4` for `x86`) off the stack and into the argument.  Then it will shrink the stack.  For instance:

```pop rax```

The top `8` bytes of the stack will end up in the `rax` register.

---

**jmp**

The `jmp` instruction will jump to an instruction address.  It is used to redirect code execution.  For instance:

```jmp 0x602010```

That instruction will cause the code execution to jump to `0x602010`, and execute whatever instruction is there.

---

**call & ret**

This is similar to the `jmp` instruction.  The difference is it will push the values of `rbp` and `rip` onto the stack, then jump to whatever address it is given.  This is used for calling functions.  After the function is finished, a `ret` instruction is called which uses the pushed values of the `rbp` and `rip` (saved base and instruction pointers) it can continue execution right where it left off.

---

**cmp**

The cmp instruction is similar to that of the sub instruction.  Except it doesn't store the result in the first argument.  It checks if the result is less than zero, greater than zero, or equal to zero.  Depending on the value it will set the flags accordingly.

---

**jnz / jz**

This `jump if not zero` and `jump if zero` instructions are pretty similar to the jump instruction.  The difference is that they will only execute the jump depending on the status of the `zero` flag.  For `jz` it will only jump if the `zero` flag is set.  The opposite is true for `jnz`.

---

# Basic Assembly Reversing Problems

The purpose of these problems is to get some experience reversing assembly code.  Try to figure out what the binaries are doing.  To biew disassembly machine code into assembly code, you can use a commands like `objdump`.
https://github.com/kablaa/CTF-Workshop/blob/master/Reversing/Challenges/IfThen/if_then

**Problem 1: Hello World**

First, let's take a look at the assembly code:

`$	objdump -D hello_world -M intel | less`

After searching through for the string `main` to find the main function, we see the following:

```
080483fb <main>:
 80483fb:       8d 4c 24 04             lea    ecx,[esp+0x4]
 80483ff:       83 e4 f0                and    esp,0xfffffff0
 8048402:       ff 71 fc                push   DWORD PTR [ecx-0x4]
 8048405:       55                      push   ebp
 8048406:       89 e5                   mov    ebp,esp
 8048408:       51                      push   ecx
 8048409:       83 ec 04                sub    esp,0x4
 804840c:       83 ec 0c                sub    esp,0xc
 804840f:       68 b0 84 04 08          push   0x80484b0
 8048414:       e8 b7 fe ff ff          call   80482d0 <puts@plt>
 8048419:       83 c4 10                add    esp,0x10
 804841c:       b8 00 00 00 00          mov    eax,0x0
 8048421:       8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4]
 8048424:       c9                      leave
 8048425:       8d 61 fc                lea    esp,[ecx-0x4]
 8048428:       c3                      ret
 8048429:       66 90                   xchg   ax,ax
 804842b:       66 90                   xchg   ax,ax
 804842d:       66 90                   xchg   ax,ax
 804842f:       90                      nop
```

Looking at the code, we see a function call to `puts`:

```
 804840f:       68 b0 84 04 08          push   0x80484b0
 8048414:       e8 b7 fe ff ff          call   80482d0 <puts@plt>
```

Looking through the rest of the code, we really don't see much else that is interesting for our perspective.  So this code probably just prints a string.  When we run the binary, we see that is correct.

---

**Problem 2: If then**

We start off by viewing the assembly code with `objdump`:

```
$	objdump -D if_then -M intel | less
```

After parsing through for the `main` function, we see this:

```
080483fb <main>:
 80483fb:       8d 4c 24 04             lea    ecx,[esp+0x4]
 80483ff:       83 e4 f0                and    esp,0xfffffff0
 8048402:       ff 71 fc                push   DWORD PTR [ecx-0x4]
 8048405:       55                      push   ebp
 8048406:       89 e5                   mov    ebp,esp
 8048408:       51                      push   ecx
 8048409:       83 ec 14                sub    esp,0x14
 804840c:       c7 45 f4 0a 00 00 00    mov    DWORD PTR [ebp-0xc],0xa
 8048413:       83 7d f4 0a             cmp    DWORD PTR [ebp-0xc],0xa
 8048417:       75 10                   jne    8048429 <main+0x2e>
 8048419:       83 ec 0c                sub    esp,0xc
 804841c:       68 c0 84 04 08          push   0x80484c0
 8048421:       e8 aa fe ff ff          call   80482d0 <puts@plt>
 8048426:       83 c4 10                add    esp,0x10
 8048429:       b8 00 00 00 00          mov    eax,0x0
 804842e:       8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4]
 8048431:       c9                      leave
 8048432:       8d 61 fc                lea    esp,[ecx-0x4]
 8048435:       c3                      ret
 8048436:       66 90                   xchg   ax,ax
 8048438:       66 90                   xchg   ax,ax
 804843a:       66 90                   xchg   ax,ax
 804843c:       66 90                   xchg   ax,ax
 804843e:       66 90                   xchg   ax,ax
```

We can see that it loads the value `0xa` into `ebp-0xc`:

```
 mov    DWORD PTR [ebp-0xc],0xa
```

Immediately proceeding that, we see that it runs a `cmp` instruction on it to check if it is equal.  If they are not equal it will jump to `main+0x2e`.  Since it was just loaded with the value `0xa`, it should not make the jump:

```
 cmp    DWORD PTR [ebp-0xc],0xa
 jne    8048429 <main+0x2e>
```

proceeding that it should make a call to puts:

```
 sub    esp,0xc
 push   0x80484c0
 80482d0 <puts@plt>
```

So after looking at this code, we see that it should make that `puts` call.  When we run it, we see that is what it does.

```
$	./if_then
	x = ten
```

---

**Problem 3: Loop**

Let's take a look at the assembly code:

```
objdump -D loop -M intel | less
```

Quickly searching for the main function, we find it:

```
080483fb <main>:
 80483fb:       8d 4c 24 04             lea    ecx,[esp+0x4]
 80483ff:       83 e4 f0                and    esp,0xfffffff0
 8048402:       ff 71 fc                push   DWORD PTR [ecx-0x4]
 8048405:       55                      push   ebp
 8048406:       89 e5                   mov    ebp,esp
 8048408:       51                      push   ecx
 8048409:       83 ec 14                sub    esp,0x14
 804840c:       c7 45 f4 00 00 00 00    mov    DWORD PTR [ebp-0xc],0x0
 8048413:       eb 17                   jmp    804842c <main+0x31>
 8048415:       83 ec 08                sub    esp,0x8
 8048418:       ff 75 f4                push   DWORD PTR [ebp-0xc]
 804841b:       68 c0 84 04 08          push   0x80484c0
 8048420:       e8 ab fe ff ff          call   80482d0 <printf@plt>
 8048425:       83 c4 10                add    esp,0x10
 8048428:       83 45 f4 01             add    DWORD PTR [ebp-0xc],0x1
 804842c:       83 7d f4 13             cmp    DWORD PTR [ebp-0xc],0x13
 8048430:       7e e3                   jle    8048415 <main+0x1a>
 8048432:       b8 00 00 00 00          mov    eax,0x0
 8048437:       8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4]
 804843a:       c9                      leave
 804843b:       8d 61 fc                lea    esp,[ecx-0x4]
 804843e:       c3                      ret
 804843f:       90                      nop
```

After defining the new stack and base pointers for the main function, we can see a variable is created and set to be 0:

```
mov    DWORD PTR [ebp-0xc],0x0
```
After that, the code jumps to `804842c <main+0x31>`

Looking at the instructions at `0x804842c` we see this:

```
 cmp    DWORD PTR [ebp-0xc],0x13
 jle    8048415 <main+0x1a>
```

This compares the value stored at the previously defined stack variable to the value of `0x13` or in decimal, 19.  If the value stored in the stack variable is less than or equal to 19, then it jumps to `0x8048415`

Taking a look at the code at that address we see this code:

```
 sub    esp,0x8
 push   DWORD PTR [ebp-0xc]
 push   0x80484c0
 call   80482d0 <printf@plt>
 add    esp,0x10
 add    DWORD PTR [ebp-0xc],0x1
```

This brings us to a printf call.  It looks like it is printing out the contents of `ebp-0xc` in some sort of format string.  After that we can see that it increments the value of `ebp-0xc`, before doing the `cmp` again.

So right, putting all of the pieces together, now we are probably looking at a for loop that will run `20` times, and print the iteraction counter each time.  Something that looks similar to this:

```c
int i = 0;
for (i = 0 ; i < 20 ; i++){
	printf("%d", i);
}
```

# ghidra

Ghidra is an open sourced decompiler.  A compiler takes source code like C, and converts it into machine code.  A decompiler tries to do the opposite.  It takes machine code and generates code that resembles its source code.  However, since the process of compiling source code isn't like a 1 to 1 function, the code it gives us isn't always 100% correct.  Even with that it can be great help, and really reduce the amount of time we spend reversing challenges (btw reversing is just the process of figuring out what something does).

Links to understand ghidra usage:

```
https://www.youtube.com/watch?v=fTGTnrgjuGA
https://www.youtube.com/watch?v=OJlKtRgC68U
https://threatvector.cylance.com/en_us/home/an-introduction-to-code-analysis-with-ghidra.html
https://ghidra-sre.org/InstallationGuide.html
```

# Debugging with GDB

First off, GDB is a debugger (specifically the gnu debugger).  Gef is a gdb wrapper, designed to give us some extended features (https://github.com/hugsy/gef). To install it, you can find instructions on the github page.

A debugger is software that allows us to perform various types of analysis of a process as it's running, and alter it in a variety of different ways.

To run a program in GDB, you can use the command:

```
gdb ./hello_world
```

In order to enter debugger mode, we can set breakpoints.  Breakpoints are places in the program where GDB will know to stop execution and allow you to examine the contents of the stack.  The most common breakpoint to set is on main, which we can set with `break main` or `b main`.  Most GDB commands can be shortened.  Check out these cheat sheets for more: 

- https://darkdust.net/files/GDB%20Cheat%20Sheet.pdf
- https://gabriellesc.github.io/teaching/resources/GDB-cheat-sheet.pdf

Now you can step through the function by typing `nexti` until the program ends.  `nexti` will have you go instruction by instruction through the program, but will not step into function calls such as puts.

Other ways to navigate a program are:

* `next` - which will take you through one line of the code, but will step over function calls such as puts.
* `step` - which will take you through one line of code, but will step into function calls.
* `stepi` - which will take you through one instruction at a time, stepping into function calls.

For each of these methods, work through the program after setting a breakpoint in main.  Take specific care to see what step and stepi see after entering puts.  Most of the time, because those are part of standard libraries, we don't need to step into anything.

---

**Breakpoints**

Let's take a look at the main function using 'disassemble' or 'disass':

```
Dump of assembler code for function main:
   0x080483fb <+0>:     lea    ecx,[esp+0x4]
   0x080483ff <+4>:     and    esp,0xfffffff0
   0x08048402 <+7>:     push   DWORD PTR [ecx-0x4]
   0x08048405 <+10>:    push   ebp
   0x08048406 <+11>:    mov    ebp,esp
   0x08048408 <+13>:    push   ecx
   0x08048409 <+14>:    sub    esp,0x4
   0x0804840c <+17>:    sub    esp,0xc
   0x0804840f <+20>:    push   0x80484b0
   0x08048414 <+25>:    call   0x80482d0 <puts@plt>
   0x08048419 <+30>:    add    esp,0x10
   0x0804841c <+33>:    mov    eax,0x0
   0x08048421 <+38>:    mov    ecx,DWORD PTR [ebp-0x4]
   0x08048424 <+41>:    leave
   0x08048425 <+42>:    lea    esp,[ecx-0x4]
   0x08048428 <+45>:    ret
End of assembler dump.
```

Let's say we wanted to break on the call to `puts`.  We can do this by setting a breakpoint for that instruction.

Like this:

```
b *main+25
```

Or like this:

```
b *0x80048414
```

When we run the binary and it tries to execute that instruction, the process will pause and drop us into the debugger console.

In the debugger console is where we can actually use the debugger to provide various types of analysis, and change things about the binary.  For now let's keep looking at breakpoints.  To show all breakpoints:

```
info breakpoints
```

or, to be short, "info b" or "i b".

Output of `info breakpoints`:

```
gef➤  info breakpoints
Num     Type           Disp Enb Address    What
1       breakpoint     keep y   0x08048409 <main+14>
```

To delete a breakpoint Num `1`:

`delete 1`

Or to be short "del 1" or "d 1".

---

**Viewing Things**

So one thing that gdb is really useful for is viewing the values of different things.  Once we are dropped into a debugger while the process is viewing, let's view the contents of the `esp` register.  To get there we will break on main, run, and then advance three instructions.

You will see that the register `esp` holds the value `0xffffd0d0` which points to the string "hello world!"

This string will be printed by `puts` (since `puts` takes a single argument which is a char pointer).  One thing in gdb when you examing things with `x`, you can specify what you want to examine it as.  Possible things include as an address `x/a`, a number of characters `x/10c` string `x/s`, as a qword `x/g`, or as a dword `x/w`.

You can view the contents of all registers by using `info registers`

You can also view the stack frame by using `info frame`.

---

**Changing Values**

As you can see, we are at the instruction for puts.  Let's say we wanted to change the contents of what will be printed.  Importantly, in many programs your ability to do this is dependent on the size of the string you are trying to replace.  If you overwrite it with something that is too large, you run the risk of overwriting other memory and breaking the program.  There are plenty of workarounds but this is rarely applicable from a bin-ex perspective.

```
set {char [12]} 0x080484b0 = "hello venus"
x/s 0x080484b0
```

Now let's say we wanted to change the value stored at the memory address `0x08048451` to `0xfacade`

```
gef➤  x/g 0x08048451
0x8048451 <__libc_csu_init+33>:	0xff08838d
gef➤  set *0x08048451 = 0xfacade
gef➤  x/g 0x08048451
0x8048451 <__libc_csu_init+33>:	0xfacade
```

Let's say we wanted to jump directly to an instruction like `0x08048451`, and skip all instructions in between:

```
j *0x08048451
Continuing at 0x0x08048451
```

---

# Scripting with Pwntools

Pwntools is a python ctf library designed for rapid exploit development.  It essentially helps us write exploits quickly, and has a lot of useful functionality behind it.

**Installation**

```bash
sudo pip install pwn
```

**Using it**

To import the module to python:

```python3
from pwn import *
```

One of the great benefits of pwntools is that it has great piping functionality which helps with IO.  If we want to connect to the server at `github.com` (if you have an IP address, just swap out the dns name with the IP address) on port `9000` via tcp:

```
target = remote("github.com", 9000)
```

If you want to run a target binary:

```
target = process("./challenge")
```

If you want to attach the `gdb` debugger to a process:

```
gdb.attach(target)
```

If we want to attach the `gdb` debugger to a process, and also immediately pass a command to `gdb` to set a breakpoint at main:

```
gdb.attach(target, gdbscript='b *main')
```
Now for actual I/O.  If we want to send the variable `x` to the `target` (target can be something like a process, or remote connection established by pwntools):

```
target.send(x)
```

If we wanted to send the variable `x` followed by a newline character appended to the end:

```
target.sendline(x)
```

If we wanted to print all text from `target`

```
print target.recvline()
```

If we wanted to print all text from `target` up to the string `out`:

```
print target.recvuntil("out")
```

Now one more thing, ELFs store data via least endian, meaning that data is stored with the least signifant byte first.  In a few situations where we are scanning in an integer, we will need to take this into account.  Luckily pwntools will take care of this for us.

To pack the integer `x` as a least endian QWORD (commonly used for `x64`):

```
p64(x)
```

To pack the integer `x` as a least endian DWORD (commonly used for `x86`):

```
p32(x)
```

It can also unpack values we get.  Let's say we wanted to unpack a least endian QWORD and get its integer value:

```
u64(x)
```

To unpack a DWORD:

```
u32(x)
```

Lastly if we wanted to directly interact with `target`:

```
target.interactive()
```

This is only a small bit of the functionality pwntools has.  You will see a lot more of the functionality later.  If you want to see more of pwntools, it has some great docs: http://docs.pwntools.com/en/stable/

---

# Intro Reversing Challenges

The following challenges were only online from the time that their CTF competitions were running.  

https://github.com/mohamedaymenkarmous/CTF/tree/master/CSAWCTFQualificationRound2018#a-tour-of-x86---part-1

These questions are in regard to the `stage1.asm` file in this directory.  This is just a text file which contains assembly code.

https://nasm.us/doc/nasmdoci.html

^ Very helpful guide to assembler

**pico ctf 2018 strings**

The goal of this challenge is to find the flag.

```
$    strings strings | grep {
picoCTF{sTrIngS_sAVeS_Time_3f712a28}
```

**helithumper re**

The goal of this challenge is the get the flag.

The binary is 'rev'

We can see that we are dealing with a `64` bit binary.  When we run it, it prompts us for input.  What is probably going on here, is it is scanning in data, and checking it.  In order to get the flag we will probably need to pass that check.

When we check the main function in Ghidra, we see this:

```c
ulong main(void)

{
  int check;
  void *ptr;
 
  ptr = calloc(0x32,1);
  puts("Welcome to the Salty Spitoon™, How tough are ya?");
  __isoc99_scanf(&DAT_0010203b,ptr);
  check = validate(ptr);
  if (check == 0) {
    puts("Yeah right. Back to Weenie Hut Jr™ with ya");
  }
  else {
    puts("Right this way...");
  }
  return (ulong)(check == 0);
}
```

So we can see that it is scanning in data to `ptr`, then running the `validate` function.  We can see that `validate` function does this:

```c
undefined8 validate(char *input)

{
  long lVar1;
  size_t inputLen;
  undefined8 returnValue;
  long in_FS_OFFSET;
  int i;
  int checkValues [4];
 
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  checkValues[0] = 0x66;
  checkValues[1] = 0x6c;
  checkValues[2] = 0x61;
  checkValues[3] = 0x67;
  inputLen = strlen(input);
  i = 0;
  do {
    if ((int)inputLen <= i) {
      returnValue = 1;
LAB_001012b7:
      if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
        __stack_chk_fail();
      }
      return returnValue;
    }
    if ((int)input[(long)i] != checkValues[(long)i]) {
      returnValue = 0;
      goto LAB_001012b7;
    }
    i = i + 1;
  } while( true );
}
```

So we can see that it essentially takes our input, and runs it through a while true loop.  For each iteration of this loop, we see that it checks one character of our input against a character in `checkValues`.  The character it checks depends on which iteration of the loop it is.  For instance iteration `0` will check the character of our input at index `0`, iteration `2` will check the character of our input at index `2` and so on.

---

# Reversing beleaf

the beleaf binary will be the first TRUE multi-step reversing problem of the Nightmare course.

Examining what type of binary it is using `file`:

```bash
$ file beleaf
beleaf: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=6d305eed7c9bebbaa60b67403a6c6f2b36de3ca4, stripped
```

We can see that it is a 64-bit ELF executable.

Let's check to see if there are any interesting strings stored in the executable:

```bash
$ strings beleaf 
/lib64/ld-linux-x86-64.so.2
g@:lo+6
libc.so.6
exit
__isoc99_scanf
puts
__stack_chk_fail
printf
strlen
__cxa_finalize
__libc_start_main
GLIBC_2.7
GLIBC_2.4
GLIBC_2.2.5
_ITM_deregisterTMCloneTable
__gmon_start__
_ITM_registerTMCloneTable
5"       
%$       
%"       
AWAVI
AUATL
[]A\A]A^A_
Enter the flag
>>> 
Incorrect!
Correct!
;*3$"
GCC: (Ubuntu 7.4.0-1ubuntu1~18.04.1) 7.4.0
.shstrtab
.interp
.note.ABI-tag
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rela.dyn
.rela.plt
.init
.plt.got
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.init_array
.fini_array
.dynamic
.data
.bss
.comment
```

We see a few (what I presume to be) functions that are a little interesting such as puts, printf, strlen, and we also see some strings that indicate the nature of what the binary does such as "Enter the flag", "incorrect", and "correct".

The next step I took was to open up the binary in `gdb` and look for functions:

```
gef➤  info functions
All defined functions:

Non-debugging symbols:
0x0000000000000680  puts@plt
0x0000000000000690  strlen@plt
0x00000000000006a0  __stack_chk_fail@plt
0x00000000000006b0  printf@plt
0x00000000000006c0  __isoc99_scanf@plt
0x00000000000006d0  exit@plt
0x00000000000006e0  __cxa_finalize@plt
```

Not seeing a main function...  This is very odd..

Opening up the binary in Ghidra, we can find the main function is located at `0x001008a1`

https://guyinatuxedo.github.io/03-beginner_re/csaw19_beleaf/index.html