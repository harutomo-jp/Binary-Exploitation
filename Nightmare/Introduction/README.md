# Introduction - 86x and x64 Assembly

Table of contents
- [Basic Instructions](#basic-instructions)
- [Basic Assembly Reversing Problems](#basic-assembly-reversing-problems)


# Basic Instructions

**mov** - The move instruciton just moves data from one register to another.  For instance:

```mov rax, rdx```

This will just move the data from the ```rdx``` register to the ```rax``` register.

---

**dereference**

If you ever see brackets like ```[]```, they are meant to dereference, which deals with pointsers.  A pointer is a value that points to a particular memory address (it is a memory address).  Dereferencing a pointer means to treat a pointer like hte value it points to.  For instance:

```mov rax, [rdx]```

Will move the value pointed to by ```rdx``` into the ```rax``` register.  On the flipside:

```mov [rax], rdx```

Will move the value of the ```rdx``` register into whatever memory is pointed to by the ```rax``` register.  The actual value of the ```rax``` register does not change. 

---

**lea**

The lea instruction calculates the address of the second operand, and moves that address in the first.  For instance:

```lea rdi, [rbx+0x10]```

This will move the address ```rbx+0x10``` into the ```rdi``` register.

---

**add**

This just adds the two values together, and stores the sum in the first argument.  For instance:

```add rax, rdx```

---

**xor**

This will perform the binary operation xor on the two arguments it is given, and stores the result in the first operation:

```xor rdx rax```

That will set the ```rdx``` register equal to ```rdx ^ rax```.

The ```and``` and ```or``` operations essentially do the same thing, except with the and or or binary operators.

---

**push**

The ```push``` instruction will grow the stack by either ```8``` bytes (for x64, 4 for x86), then push the contents of a register onto the new stack space.  For instance:

```push rax```

This will grow the stack by 8 bytes, and the contents of the ```rax``` register will be on top of the stack.

---

**pop**

The ```pop``` instruction will pop the top `8` bytes (for `x64`, `4` for `x86`) off the stack and into the argument.  Then it will shrink the stack.  For instance:

```pop rax```

The top `8` bytes of the stack will end up in the `rax` register.

---

**jmp**

The `jmp` instruction will jump to an instruction address.  It is used to redirect code execution.  For instance:

```jmp 0x602010```

That instruction will cause the code execution to jump to `0x602010`, and execute whatever instruction is there.

---

**call & ret**

This is similar to the `jmp` instruction.  The difference is it will push the values of `rbp` and `rip` onto the stack, then jump to whatever address it is given.  This is used for calling functions.  After the function is finished, a `ret` instruction is called which uses the pushed values of the `rbp` and `rip` (saved base and instruction pointers) it can continue execution right where it left off.

---

**cmp**

The cmp instruction is similar to that of the sub instruction.  Except it doesn't store the result in the first argument.  It checks if the result is less than zero, greater than zero, or equal to zero.  Depending on the value it will set the flags accordingly.

---

**jnz / jz**

This `jump if not zero` and `jump if zero` instructions are pretty similar to the jump instruction.  The difference is that they will only execute the jump depending on the status of the `zero` flag.  For `jz` it will only jump if the `zero` flag is set.  The opposite is true for `jnz`.

---

# Basic Assembly Reversing Problems

The purpose of these problems is to get some experience reversing assembly code.  Try to figure out what the binaries are doing.  To biew disassembly machine code into assembly code, you can use a commands like `objdump`.
https://github.com/kablaa/CTF-Workshop/blob/master/Reversing/Challenges/IfThen/if_then

**Problem 1: Hello World**

First, let's take a look at the assembly code:

`$	objdump -D hello_world -M intel | less`

After searching through for the string `main` to find the main function, we see the following:

```
080483fb <main>:
 80483fb:       8d 4c 24 04             lea    ecx,[esp+0x4]
 80483ff:       83 e4 f0                and    esp,0xfffffff0
 8048402:       ff 71 fc                push   DWORD PTR [ecx-0x4]
 8048405:       55                      push   ebp
 8048406:       89 e5                   mov    ebp,esp
 8048408:       51                      push   ecx
 8048409:       83 ec 04                sub    esp,0x4
 804840c:       83 ec 0c                sub    esp,0xc
 804840f:       68 b0 84 04 08          push   0x80484b0
 8048414:       e8 b7 fe ff ff          call   80482d0 <puts@plt>
 8048419:       83 c4 10                add    esp,0x10
 804841c:       b8 00 00 00 00          mov    eax,0x0
 8048421:       8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4]
 8048424:       c9                      leave
 8048425:       8d 61 fc                lea    esp,[ecx-0x4]
 8048428:       c3                      ret
 8048429:       66 90                   xchg   ax,ax
 804842b:       66 90                   xchg   ax,ax
 804842d:       66 90                   xchg   ax,ax
 804842f:       90                      nop
```

Looking at the code, we see a function call to `puts`:

```
 804840f:       68 b0 84 04 08          push   0x80484b0
 8048414:       e8 b7 fe ff ff          call   80482d0 <puts@plt>
```

Looking through the rest of the code, we really don't see much else that is interesting for our perspective.  So this code probably just prints a string.  When we run the binary, we see that is correct.

---

**Problem 2: If then**

We start off by viewing the assembly code with `objdump`:

```
$	objdump -D if_then -M intel | less
```

After parsing through for the `main` function, we see this:

```
080483fb <main>:
 80483fb:       8d 4c 24 04             lea    ecx,[esp+0x4]
 80483ff:       83 e4 f0                and    esp,0xfffffff0
 8048402:       ff 71 fc                push   DWORD PTR [ecx-0x4]
 8048405:       55                      push   ebp
 8048406:       89 e5                   mov    ebp,esp
 8048408:       51                      push   ecx
 8048409:       83 ec 14                sub    esp,0x14
 804840c:       c7 45 f4 0a 00 00 00    mov    DWORD PTR [ebp-0xc],0xa
 8048413:       83 7d f4 0a             cmp    DWORD PTR [ebp-0xc],0xa
 8048417:       75 10                   jne    8048429 <main+0x2e>
 8048419:       83 ec 0c                sub    esp,0xc
 804841c:       68 c0 84 04 08          push   0x80484c0
 8048421:       e8 aa fe ff ff          call   80482d0 <puts@plt>
 8048426:       83 c4 10                add    esp,0x10
 8048429:       b8 00 00 00 00          mov    eax,0x0
 804842e:       8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4]
 8048431:       c9                      leave
 8048432:       8d 61 fc                lea    esp,[ecx-0x4]
 8048435:       c3                      ret
 8048436:       66 90                   xchg   ax,ax
 8048438:       66 90                   xchg   ax,ax
 804843a:       66 90                   xchg   ax,ax
 804843c:       66 90                   xchg   ax,ax
 804843e:       66 90                   xchg   ax,ax
```

We can see that it loads the value `0xa` into `ebp-0xc`:

```
 mov    DWORD PTR [ebp-0xc],0xa
```

Immediately proceeding that, we see that it runs a `cmp` instruction on it to check if it is equal.  If they are not equal it will jump to `main+0x2e`.  Since it was just loaded with the value `0xa`, it should not make the jump:

```
 cmp    DWORD PTR [ebp-0xc],0xa
 jne    8048429 <main+0x2e>
```

proceeding that it should make a call to puts:

```
 sub    esp,0xc
 push   0x80484c0
 80482d0 <puts@plt>
```

So after looking at this code, we see that it should make that `puts` call.  When we run it, we see that is what it does.

```
$	./if_then
	x = ten
```

---

**Problem 3: Loop**

Let's take a look at the assembly code:

```
objdump -D loop -M intel | less
```

Quickly searching for the main function, we find it:

```
080483fb <main>:
 80483fb:       8d 4c 24 04             lea    ecx,[esp+0x4]
 80483ff:       83 e4 f0                and    esp,0xfffffff0
 8048402:       ff 71 fc                push   DWORD PTR [ecx-0x4]
 8048405:       55                      push   ebp
 8048406:       89 e5                   mov    ebp,esp
 8048408:       51                      push   ecx
 8048409:       83 ec 14                sub    esp,0x14
 804840c:       c7 45 f4 00 00 00 00    mov    DWORD PTR [ebp-0xc],0x0
 8048413:       eb 17                   jmp    804842c <main+0x31>
 8048415:       83 ec 08                sub    esp,0x8
 8048418:       ff 75 f4                push   DWORD PTR [ebp-0xc]
 804841b:       68 c0 84 04 08          push   0x80484c0
 8048420:       e8 ab fe ff ff          call   80482d0 <printf@plt>
 8048425:       83 c4 10                add    esp,0x10
 8048428:       83 45 f4 01             add    DWORD PTR [ebp-0xc],0x1
 804842c:       83 7d f4 13             cmp    DWORD PTR [ebp-0xc],0x13
 8048430:       7e e3                   jle    8048415 <main+0x1a>
 8048432:       b8 00 00 00 00          mov    eax,0x0
 8048437:       8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4]
 804843a:       c9                      leave
 804843b:       8d 61 fc                lea    esp,[ecx-0x4]
 804843e:       c3                      ret
 804843f:       90                      nop
```

After defining the new stack and base pointers for the main function, we can see a variable is created and set to be 0:

```
mov    DWORD PTR [ebp-0xc],0x0
```
After that, the code jumps to `804842c <main+0x31>`

Looking at the instructions at `0x804842c` we see this:

```
 cmp    DWORD PTR [ebp-0xc],0x13
 jle    8048415 <main+0x1a>
```

This compares the value stored at the previously defined stack variable to the value of `0x13` or in decimal, 19.  If the value stored in the stack variable is less than or equal to 19, then it jumps to `0x8048415`

Taking a look at the code at that address we see this code:

```
 sub    esp,0x8
 push   DWORD PTR [ebp-0xc]
 push   0x80484c0
 call   80482d0 <printf@plt>
 add    esp,0x10
 add    DWORD PTR [ebp-0xc],0x1
```

This brings us to a printf call.  It looks like it is printing out the contents of `ebp-0xc` in some sort of format string.  After that we can see that it increments the value of `ebp-0xc`, before doing the `cmp` again.

So right, putting all of the pieces together, now we are probably looking at a for loop that will run `20` times, and print the iteraction counter each time.  Something that looks similar to this:

```c
int i = 0;
for (i = 0 ; i < 20 ; i++){
	printf("%d", i);
}
```

# ghidra

Ghidra is an open sourced decompiler.  A compiler takes source code like C, and converts it into machine code.  A decompiler tries to do the opposite.  It takes machine code and generates code that resembles its source code.  However, since the process of compiling source code isn't like a 1 to 1 function, the code it gives us isn't always 100% correct.  Even with that it can be great help, and really reduce the amount of time we spend reversing challenges (btw reversing is just the process of figuring out what something does).

Links to understand ghidra usage:

```
https://www.youtube.com/watch?v=fTGTnrgjuGA
https://www.youtube.com/watch?v=OJlKtRgC68U
https://threatvector.cylance.com/en_us/home/an-introduction-to-code-analysis-with-ghidra.html
https://ghidra-sre.org/InstallationGuide.html
```

# Debugging with GDB

First off, GDB is a debugger (specifically the gnu debugger).  Gef is a gdb wrapper, designed to give us some extended features (https://github.com/hugsy/gef). To install it, you can find instructions on the github page.

A debugger is software that allows us to perform various types of analysis of a process as it's running, and alter it in a variety of different ways.

To run a program in GDB, you can use the command:

```
gdb ./hello_world
```

In order to enter debugger mode, we can set breakpoints.  Breakpoints are places in the program where GDB will know to stop execution and allow you to examine the contents of the stack.  The most common breakpoint to set is on main, which we can set with `break main` or `b main`.  Most GDB commands can be shortened.  Check out these cheat sheets for more: 

- https://darkdust.net/files/GDB%20Cheat%20Sheet.pdf
- https://gabriellesc.github.io/teaching/resources/GDB-cheat-sheet.pdf

Now you can step through the function by typing `nexti` until the program ends.  `nexti` will have you go instruction by instruction through the program, but will not step into function calls such as puts.

Other ways to navigate a program are:

* `next` - which will take you through one line of the code, but will step over function calls such as puts.
* `step` - which will take you through one line of code, but will step into function calls.
* `stepi` - which will take you through one instruction at a time, stepping into function calls.

For each of these methods, work through the program after setting a breakpoint in main.  Take specific care to see what step and stepi see after entering puts.  Most of the time, because those are part of standard libraries, we don't need to step into anything.